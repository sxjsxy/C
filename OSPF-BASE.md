**路由获悉**
	对一台路由器而言，有直连路由和非直连路由
	直连路由只要接口状态up，配了ip和掩码就能自动获悉它的路由信息
	非直连路由则需要配置 静态路由或者动态路由
	
**协议使用环境**
	静态路由不灵活，当静态路由转发数据的时候，是无法感知网络拓扑的稳定性。
	不能感知链路行不行。
	就像x去y网络有a，b两条路可以走，但是静态只配置了a路径，如果a路径down了，静态路由是不会感知b可以走的，还是会从a走。
	
	静态路由不支持自适应性。
	
**重收敛**
	利用网络的冗余性，来感知链路上有不同的路径通往目的网络，来立即切换到备份路径去访问目的网络。
	
	在动态路由协议中就能实现这种自适应的调整。

# OSPF
	开放式最短路径优先协议
是IGP类和LS类、支持中到大型的AS园区
	
**为什么要使用动态路由选择协议**
1. 因为静态路由无法动态响应网络变化
2. 动态路由选择协议可以
3. 因为OSPF连接时每个路由器都知道对方的网络信息：ip,接口，链路信息。
4. 所以如果当r1到r2断开了，r1就会自动寻路，从r1-r3-r2自动收敛。
	

### 一、LSA泛洪
LS协议通告的是链路状态，而不是路由表。

建立邻居关系 发送Hello报文
1. 直连路由器之间发送Hello报文
2. 然后彼此之间发送更新信息
3. 不过LS的更新信息不包含路由条目，而是LSA

**LSA链路状态通告**
1. 包含路由信息和拓扑信息
2. 不同类型的LSA，包含的信息不一样
3. 并且不同的LSA的产生的路由器不一样
4. 最关键的是一类LSA

**一类LSA**
1. 我是什么样的路由器
2. 我属于一个区域或是多个区域
3. 我有那些接口参与了ospf，是否参与路由重分发
4. 接口的网络类型，有没有建立其他的ospf邻居，邻居是谁？
5. IP 掩码 度量值

因为这个信息很客观，大家都知道这些信息，所以可以用这些信息来计算路由。

### 二、LSDB组建
**链路状态数据库**
路由器将接收到的LSA放入自己的LSDB。
LSDB汇总了网络中的路由器对自己接口的描述
LSDB汇总了全网拓扑的描述

基于这张表LSDB来计算通往目的网络的最优路径

### 三、SPF计算
路由器基于LSDB使用SPF算法进行计算
计算出 以自己为根，无环，最短路径的树。
路由器知道到达网络各个角落的优选路径。

	• 不会出现环路

### 四、路由表生成
最后，路由器将计算出来的优选路径加入进自己的路由表

1. 建立了邻居关系
2. 共享链路状态信息 LSDB
3. 路径计算
4. 生成路由表项


LSA泛洪 - 邻居表
LSDB组件 - LSDB表
路由表

OSPF简介
	• 非常广泛的IGP协议
	• V2版本针对IPv4，V3版本针对IPv6
	• OSPF路由器之间交互的是LSA，而不是直接交互路由信息。
	• OSPF将网络中的LSA收集在LSDB中，帮助计算
	• 使用SPF算法来算出路由条目，存在路由表中
	• 支持VLSM，支持手工路由汇总。
	• 可以多区域OSPF来支持更大的网络

区域
	• OSPF Area表示一个OSPF区域
	• 在逻辑上划分设备，每组用区域号标识
	• 为了让设备中的信息更少，在网络很大的时候使用多区域。 
	• 分为骨干区域（Area 0）和非骨干区域（其他区域）
	
	非骨干区域必须与骨干区域挂靠。

Router ID
	• 每台运行OSPF的路由器都有一个Router ID
	• 用来表示在OSPF域中的标识
	• 可以手工配置，也可以系统自动配置
	
	Router ID看似IP地址，但不是IP地址，格式也是xxx.xxx.xxx.xxx
	
	华为选举方式
		1. 状态最早为接口UP的路由器
		2. 经常会换，建议手工指定ID
		
度量值
	OSPF使用Cost作为路由的度量值。
	默认Cost值是算法 100M/接口带宽 
	即100M的带宽度量值是1，1.544M是64
	但是因为Cost最小为1，所以即使是1000M或万兆 Cost也是1.
	所以建议修改这个算法。
	
OSPF协议报文类型
报文名称	报文功能
Hello	周期性的发送，发现和维护OSPF邻居关系
	• 周期判断计时器，Hello时间分为10秒一次和30秒一次
	• 如果4倍Hello时间后还没有收到邻居关系，那么就会删除这个OSPF邻居，并且删除从这个邻居所学到的路由。40秒或120秒。

报文名称	报文功能
Database Description	描述本地LSDB的摘要信息，用于两台设备进行数据库同步。
	• 因为网络中每个设备的LSDB信息可能是重复的。所以不需要一下子把所有LSA信息都发了。
	• 告诉对方我有哪里数据库存在，然后对面在告诉我它有那些数据库存在，避免重复。
	• 但是如果LSA条目非常多，甚至几万条。所以需要确认交互。

报文名称	报文功能
Link State Request	用于向对方请求所需要的LSA。只有在OSPF邻居双方成功交换DD报文后才会发出LSR保温。
Link State  Update	用于向对方发送其所需要的LSA。
Link State ACK	对收到的LSA进行确认
	• 确认机制用两种 显示确认 和 隐式确认
	• 显示确认
		○ A给B发一个DBD后，B回A一个ACK
		○ 单纯的回ACK确认
		○ 例如TCP就是显示确认机制
	• 隐式确认
		1. A给B发送DBD(序列号100)
		2. B回A一个DBD(序列号100)
		3. B发送的DBD来代表确认收到 和确认是序列号100的DBD

	• OSPF采用隐式确认
		○ 第一个发送DBD的是Master，后发DBD的是Slave
		○ Master主动发送第一个包，Slave进行隐式确认
		○ Master定义序列号
		○ 一般比较路由器ID来选举出Master

选举主从
如何比较路由器ID？
	1. 在交互完Hello报文后就知道双方的Router ID了
	2. 在交换DBD报文时了解对方能不能做Master，这个DBD报文中只有自己的Router ID。
	3. 对方也发送一个DBD，也只有对方的Router ID。
	4. 通过双方的Router ID来进行选举。
	

交换LSA
	1. A需要B的一条LSA，所以向B发送LSR
	2. B收到LSR，回A一个LSU
	3. A在回B一个ACK表示收到LSA

OSPF邻居表
查看邻居表
<R1>display ospf peer

	1. 如果路由器之间仅交互过Hello报文；叫邻居状态 Two-way
	不能交互LSA，因为数据库没有同步。
	2. 交互过DBD，选举出了主从，完成了LSDB同步，[五种报文都交互过了]；叫邻接状态 Full
	在Full状态就能自由交换LSA信息
	
	如果没有到达Full可能需要排错。
	
OSPF-LSDB表
查看LSDB表
<R1>Display ospf lsdb

LSA拥有11类

	• type字段表示LSA类型
	• AdvRouter表示初始发送LSA路由器的Router ID
	• LinkState ID就是LSA的名字
	• age年龄，len长度，sequence序列号，metric
以上6个字段，只是LSA的报头。

OSPF路由表
显示OSPF路由表
[R1]display ospf routing

邻接关系建立

	1. 通过Hello建立邻居关系
	2. 交互DBD后，协商主从
	3. 交互DBD，描述各自的LSDB的摘要信息
	4. 更新LSA，同步LSDB
	5. 计算路由

流程-1
	• Neighbor字段，当前已知的邻居，是邻居的Router ID。
	• 如果不知道别的邻居，没有别人给我过Hello报文，那么这个字段为0


	1. 因为R1收到的Hello报文中的Neighbor字段中，有R1自身的信息 ，那么代表对方收到过R1的Hello报文。
	2. 所以R1中R2的状态是2-way
	3. R1再次发送Hello报文给R2，告诉R2我发现你了，Neighbor字段中有R2
	4. R2收到R1的Hello，发现Neighbor中有自己，那么R1对R2也是2-way


流程2&3

	1. 路由ID小的哪一方给路由ID大的路由器做隐式确认。这个过程叫ex-start
	2. exchange阶段来交换LSA摘要信息。然后就可以开始交换你有我无，我有你无的LSA信息了。

流程-4


流程分为
	1. Init
	• 收到Hello，报文中没有我，那么对我而言它只是单边邻居。
	2. 2-way
	• A给B发的报文的neigbor字段中有B，那么B就把A当邻居，也就是2-way
	3. Ex-start
	• 选举DB
	4. Exchange
	• 主路由器来发送带有LSA摘要的报文，采用隐式确认
	5. Loading
	• 实际的数据库同步
	6. Full
	• 完全的邻接关系

邻居表
DR：主路由器
BDR：备份主路由器


